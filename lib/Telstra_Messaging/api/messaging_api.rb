=begin
#Telstra Messaging API

#The Telstra Messaging API specification

The version of the OpenAPI document: 2.2.9

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 4.2.3-SNAPSHOT

=end

require 'cgi'

module Telstra_Messaging
  class MessagingApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Get MMS Status
    # Get MMS Status
    # @param messageid [String] Unique identifier of a message - it is the value returned from a previous POST call to https://tapi.telstra.com/v2/messages/mms 
    # @param [Hash] opts the optional parameters
    # @return [Array<OutboundPollResponse>]
    def get_mms_status(messageid, opts = {})
      data, _status_code, _headers = get_mms_status_with_http_info(messageid, opts)
      data
    end

    # Get MMS Status
    # Get MMS Status
    # @param messageid [String] Unique identifier of a message - it is the value returned from a previous POST call to https://tapi.telstra.com/v2/messages/mms 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<OutboundPollResponse>, Integer, Hash)>] Array<OutboundPollResponse> data, response status code and response headers
    def get_mms_status_with_http_info(messageid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.get_mms_status ...'
      end
      # verify the required parameter 'messageid' is set
      if @api_client.config.client_side_validation && messageid.nil?
        fail ArgumentError, "Missing the required parameter 'messageid' when calling MessagingApi.get_mms_status"
      end
      # resource path
      local_var_path = '/messages/mms/{messageid}/status'.sub('{' + 'messageid' + '}', CGI.escape(messageid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'Array<OutboundPollResponse>' 

      # auth_names
      auth_names = opts[:auth_names] || ['auth']

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#get_mms_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get SMS Status
    # If no notification URL has been specified, it is possible to poll for the message status.  Note that the `MessageId` that appears in the URL must be URL encoded. Just copying the `MessageId` as it was supplied when submitting the message may not work.  # SMS Status with Notification URL  When a message has reached its final state, the API will send a POST to the URL that has been previously specified.  <pre><code class=\"language-sh\">{     \"to\": \"+61418123456\",     \"sentTimestamp\": \"2017-03-17T10:05:22+10:00\",     \"receivedTimestamp\": \"2017-03-17T10:05:23+10:00\",     \"messageId\": \"1234567890ABCDEFGHIJKLNOPQRSTUVW\",     \"deliveryStatus\": \"DELIVRD\"   } </code></pre>  The fields are:  | Field | Description | | --- | ---| | `to` |  The number the message was sent to. | | `receivedTimestamp` | Time the message was sent to the API. | | `sentTimestamp` | Time handling of the message ended. | | `deliveryStatus` | The final state of the message. | | `messageId` | The same reference that was returned when the original message was sent.| | `receivedTimestamp` | Time the message was sent to the API.|  Upon receiving this call it is expected that your servers will give a 204 (No Content) response. 
    # @param message_id [String] Unique identifier of a message - it is the value returned from a previous POST call to https://tapi.telstra.com/v2/messages/sms. 
    # @param [Hash] opts the optional parameters
    # @return [Array<OutboundPollResponse>]
    def get_sms_status(message_id, opts = {})
      data, _status_code, _headers = get_sms_status_with_http_info(message_id, opts)
      data
    end

    # Get SMS Status
    # If no notification URL has been specified, it is possible to poll for the message status.  Note that the &#x60;MessageId&#x60; that appears in the URL must be URL encoded. Just copying the &#x60;MessageId&#x60; as it was supplied when submitting the message may not work.  # SMS Status with Notification URL  When a message has reached its final state, the API will send a POST to the URL that has been previously specified.  &lt;pre&gt;&lt;code class&#x3D;\&quot;language-sh\&quot;&gt;{     \&quot;to\&quot;: \&quot;+61418123456\&quot;,     \&quot;sentTimestamp\&quot;: \&quot;2017-03-17T10:05:22+10:00\&quot;,     \&quot;receivedTimestamp\&quot;: \&quot;2017-03-17T10:05:23+10:00\&quot;,     \&quot;messageId\&quot;: \&quot;1234567890ABCDEFGHIJKLNOPQRSTUVW\&quot;,     \&quot;deliveryStatus\&quot;: \&quot;DELIVRD\&quot;   } &lt;/code&gt;&lt;/pre&gt;  The fields are:  | Field | Description | | --- | ---| | &#x60;to&#x60; |  The number the message was sent to. | | &#x60;receivedTimestamp&#x60; | Time the message was sent to the API. | | &#x60;sentTimestamp&#x60; | Time handling of the message ended. | | &#x60;deliveryStatus&#x60; | The final state of the message. | | &#x60;messageId&#x60; | The same reference that was returned when the original message was sent.| | &#x60;receivedTimestamp&#x60; | Time the message was sent to the API.|  Upon receiving this call it is expected that your servers will give a 204 (No Content) response. 
    # @param message_id [String] Unique identifier of a message - it is the value returned from a previous POST call to https://tapi.telstra.com/v2/messages/sms. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<OutboundPollResponse>, Integer, Hash)>] Array<OutboundPollResponse> data, response status code and response headers
    def get_sms_status_with_http_info(message_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.get_sms_status ...'
      end
      # verify the required parameter 'message_id' is set
      if @api_client.config.client_side_validation && message_id.nil?
        fail ArgumentError, "Missing the required parameter 'message_id' when calling MessagingApi.get_sms_status"
      end
      # resource path
      local_var_path = '/messages/sms/{messageId}/status'.sub('{' + 'messageId' + '}', CGI.escape(message_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'Array<OutboundPollResponse>' 

      # auth_names
      auth_names = opts[:auth_names] || ['auth']

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#get_sms_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # MMS Health Check
    # Determine whether the MMS service is up or down. 
    # @param [Hash] opts the optional parameters
    # @return [HealthCheckResponse]
    def m_ms_health_check(opts = {})
      data, _status_code, _headers = m_ms_health_check_with_http_info(opts)
      data
    end

    # MMS Health Check
    # Determine whether the MMS service is up or down. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(HealthCheckResponse, Integer, Hash)>] HealthCheckResponse data, response status code and response headers
    def m_ms_health_check_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.m_ms_health_check ...'
      end
      # resource path
      local_var_path = '/messages/mms/healthcheck'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'HealthCheckResponse' 

      # auth_names
      auth_names = opts[:auth_names] || []

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#m_ms_health_check\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve MMS Replies
    # Messages are retrieved one at a time, starting with the earliest reply.  If the subscription has a `notifyURL`, reply messages will be logged there instead, i.e. `GET` and reply `notifyURL` are exclusive.  # MMS Reply with Notification URL  When a reply is received, the API will send a POST to the subscription URL that has been previously specified.  <pre><code class=\"language-sh\">{   \"to\": \"+61418123456\",   \"from\": \"+61421987654\",   \"sentTimestamp\": \"2018-03-23T12:15:45+10:00\",   \"messageId\": \"XFRO1ApiA0000000111\",   \"subject\": \"Foo\",   \"envelope\": \"string\",   \"MMSContent\":     [       {         \"type\": \"text/plain\",         \"filename\": \"text_1.txt\",         \"payload\": \"string\"       },       {         \"type\": \"image/jpeg\",         \"filename\": \"sample.jpeg\",         \"payload\": \"string\"       }     ] }</code></pre>  The fields are:  | Field | Description | | --- | --- | | `to` |The number the message was sent to. | | `from` | The number the message was sent from. | | `sentTimestamp` | Time handling of the message ended. | | `messageId` | Message Id assigned by the MMSC | | `subject` | The subject assigned to the message. | | `envelope` | Information about about terminal type and originating operator. | | `MMSContent` | An array of the actual content of the reply message. | | `type` | The content type of the message. | | `filename` | The filename for the message content. | | `payload` | The content of the message. | 
    # @param [Hash] opts the optional parameters
    # @return [GetMmsResponse]
    def retrieve_mms_replies(opts = {})
      data, _status_code, _headers = retrieve_mms_replies_with_http_info(opts)
      data
    end

    # Retrieve MMS Replies
    # Messages are retrieved one at a time, starting with the earliest reply.  If the subscription has a &#x60;notifyURL&#x60;, reply messages will be logged there instead, i.e. &#x60;GET&#x60; and reply &#x60;notifyURL&#x60; are exclusive.  # MMS Reply with Notification URL  When a reply is received, the API will send a POST to the subscription URL that has been previously specified.  &lt;pre&gt;&lt;code class&#x3D;\&quot;language-sh\&quot;&gt;{   \&quot;to\&quot;: \&quot;+61418123456\&quot;,   \&quot;from\&quot;: \&quot;+61421987654\&quot;,   \&quot;sentTimestamp\&quot;: \&quot;2018-03-23T12:15:45+10:00\&quot;,   \&quot;messageId\&quot;: \&quot;XFRO1ApiA0000000111\&quot;,   \&quot;subject\&quot;: \&quot;Foo\&quot;,   \&quot;envelope\&quot;: \&quot;string\&quot;,   \&quot;MMSContent\&quot;:     [       {         \&quot;type\&quot;: \&quot;text/plain\&quot;,         \&quot;filename\&quot;: \&quot;text_1.txt\&quot;,         \&quot;payload\&quot;: \&quot;string\&quot;       },       {         \&quot;type\&quot;: \&quot;image/jpeg\&quot;,         \&quot;filename\&quot;: \&quot;sample.jpeg\&quot;,         \&quot;payload\&quot;: \&quot;string\&quot;       }     ] }&lt;/code&gt;&lt;/pre&gt;  The fields are:  | Field | Description | | --- | --- | | &#x60;to&#x60; |The number the message was sent to. | | &#x60;from&#x60; | The number the message was sent from. | | &#x60;sentTimestamp&#x60; | Time handling of the message ended. | | &#x60;messageId&#x60; | Message Id assigned by the MMSC | | &#x60;subject&#x60; | The subject assigned to the message. | | &#x60;envelope&#x60; | Information about about terminal type and originating operator. | | &#x60;MMSContent&#x60; | An array of the actual content of the reply message. | | &#x60;type&#x60; | The content type of the message. | | &#x60;filename&#x60; | The filename for the message content. | | &#x60;payload&#x60; | The content of the message. | 
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetMmsResponse, Integer, Hash)>] GetMmsResponse data, response status code and response headers
    def retrieve_mms_replies_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.retrieve_mms_replies ...'
      end
      # resource path
      local_var_path = '/messages/mms'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'GetMmsResponse' 

      # auth_names
      auth_names = opts[:auth_names] || ['auth']

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#retrieve_mms_replies\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve SMS Replies
    # Messages are retrieved one at a time, starting with the earliest reply.  The API supports the encoding of emojis in the reply message. The emojis will be in their UTF-8 format.  If the subscription has a `notifyURL`, reply messages will be logged there instead.  # SMS Reply with Notification URL  When a reply is received, the API will send a POST to the subscription URL that has been previously specified.  <pre><code class=\"language-sh\">{   \"to\":\"+61472880123\",   \"from\":\"+61412345678\",   \"body\":\"Foo4\",   \"sentTimestamp\":\"2018-04-20T14:24:35\",   \"messageId\":\"DMASApiA0000000146\" }</code></pre>  The fields are:  | Field | Description | | --- |--- | | `to` | The number the message was sent to. | | `from` | The number the message was sent from. | | `body` | The content of the SMS response. | | `sentTimestamp` | Time handling of the message ended. | | `messageId` | The ID assigned to the message. | 
    # @param [Hash] opts the optional parameters
    # @return [InboundPollResponse]
    def retrieve_sms_replies(opts = {})
      data, _status_code, _headers = retrieve_sms_replies_with_http_info(opts)
      data
    end

    # Retrieve SMS Replies
    # Messages are retrieved one at a time, starting with the earliest reply.  The API supports the encoding of emojis in the reply message. The emojis will be in their UTF-8 format.  If the subscription has a &#x60;notifyURL&#x60;, reply messages will be logged there instead.  # SMS Reply with Notification URL  When a reply is received, the API will send a POST to the subscription URL that has been previously specified.  &lt;pre&gt;&lt;code class&#x3D;\&quot;language-sh\&quot;&gt;{   \&quot;to\&quot;:\&quot;+61472880123\&quot;,   \&quot;from\&quot;:\&quot;+61412345678\&quot;,   \&quot;body\&quot;:\&quot;Foo4\&quot;,   \&quot;sentTimestamp\&quot;:\&quot;2018-04-20T14:24:35\&quot;,   \&quot;messageId\&quot;:\&quot;DMASApiA0000000146\&quot; }&lt;/code&gt;&lt;/pre&gt;  The fields are:  | Field | Description | | --- |--- | | &#x60;to&#x60; | The number the message was sent to. | | &#x60;from&#x60; | The number the message was sent from. | | &#x60;body&#x60; | The content of the SMS response. | | &#x60;sentTimestamp&#x60; | Time handling of the message ended. | | &#x60;messageId&#x60; | The ID assigned to the message. | 
    # @param [Hash] opts the optional parameters
    # @return [Array<(InboundPollResponse, Integer, Hash)>] InboundPollResponse data, response status code and response headers
    def retrieve_sms_replies_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.retrieve_sms_replies ...'
      end
      # resource path
      local_var_path = '/messages/sms'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'InboundPollResponse' 

      # auth_names
      auth_names = opts[:auth_names] || ['auth']

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#retrieve_sms_replies\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # SMS Health Check
    # Determine whether the SMS service is up or down. 
    # @param [Hash] opts the optional parameters
    # @return [HealthCheckResponse]
    def s_ms_health_check(opts = {})
      data, _status_code, _headers = s_ms_health_check_with_http_info(opts)
      data
    end

    # SMS Health Check
    # Determine whether the SMS service is up or down. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(HealthCheckResponse, Integer, Hash)>] HealthCheckResponse data, response status code and response headers
    def s_ms_health_check_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.s_ms_health_check ...'
      end
      # resource path
      local_var_path = '/messages/sms/healthcheck'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] 

      # return_type
      return_type = opts[:return_type] || 'HealthCheckResponse' 

      # auth_names
      auth_names = opts[:auth_names] || []

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#s_ms_health_check\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send Multiple SMS
    # Send multiple SMS in one API call. 
    # @param payload [SendSmsMultiRequest] A JSON payload containing the recipient&#39;s phone number and text message. This number can be in international format if preceeded by a &#39;+&#39; or in national format (&#39;04xxxxxxxx&#39;) where x is a digit. 
    # @param [Hash] opts the optional parameters
    # @return [MessageSentResponseSms]
    def s_ms_multi(payload, opts = {})
      data, _status_code, _headers = s_ms_multi_with_http_info(payload, opts)
      data
    end

    # Send Multiple SMS
    # Send multiple SMS in one API call. 
    # @param payload [SendSmsMultiRequest] A JSON payload containing the recipient&#39;s phone number and text message. This number can be in international format if preceeded by a &#39;+&#39; or in national format (&#39;04xxxxxxxx&#39;) where x is a digit. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MessageSentResponseSms, Integer, Hash)>] MessageSentResponseSms data, response status code and response headers
    def s_ms_multi_with_http_info(payload, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.s_ms_multi ...'
      end
      # verify the required parameter 'payload' is set
      if @api_client.config.client_side_validation && payload.nil?
        fail ArgumentError, "Missing the required parameter 'payload' when calling MessagingApi.s_ms_multi"
      end
      # resource path
      local_var_path = '/messages/sms/multi'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(payload) 

      # return_type
      return_type = opts[:return_type] || 'MessageSentResponseSms' 

      # auth_names
      auth_names = opts[:auth_names] || ['auth']

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#s_ms_multi\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send MMS
    # Send MMS
    # @param body [SendMmsRequest] A JSON or XML payload containing the recipient&#39;s phone number and MMS message. The recipient number should be in the format &#39;04xxxxxxxx&#39; where x is a digit. 
    # @param [Hash] opts the optional parameters
    # @return [MessageSentResponseMms]
    def send_mms(body, opts = {})
      data, _status_code, _headers = send_mms_with_http_info(body, opts)
      data
    end

    # Send MMS
    # Send MMS
    # @param body [SendMmsRequest] A JSON or XML payload containing the recipient&#39;s phone number and MMS message. The recipient number should be in the format &#39;04xxxxxxxx&#39; where x is a digit. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MessageSentResponseMms, Integer, Hash)>] MessageSentResponseMms data, response status code and response headers
    def send_mms_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.send_mms ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling MessagingApi.send_mms"
      end
      # resource path
      local_var_path = '/messages/mms'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(body) 

      # return_type
      return_type = opts[:return_type] || 'MessageSentResponseMms' 

      # auth_names
      auth_names = opts[:auth_names] || ['auth']

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#send_mms\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send SMS
    # Send an SMS Message to a single or multiple mobile number/s. 
    # @param payload [SendSMSRequest] A JSON or XML payload containing the recipient&#39;s phone number and text message. This number can be in international format if preceeded by a &#39;+&#39; or in national format (&#39;04xxxxxxxx&#39;) where x is a digit. 
    # @param [Hash] opts the optional parameters
    # @return [MessageSentResponseSms]
    def send_sms(payload, opts = {})
      data, _status_code, _headers = send_sms_with_http_info(payload, opts)
      data
    end

    # Send SMS
    # Send an SMS Message to a single or multiple mobile number/s. 
    # @param payload [SendSMSRequest] A JSON or XML payload containing the recipient&#39;s phone number and text message. This number can be in international format if preceeded by a &#39;+&#39; or in national format (&#39;04xxxxxxxx&#39;) where x is a digit. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(MessageSentResponseSms, Integer, Hash)>] MessageSentResponseSms data, response status code and response headers
    def send_sms_with_http_info(payload, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: MessagingApi.send_sms ...'
      end
      # verify the required parameter 'payload' is set
      if @api_client.config.client_side_validation && payload.nil?
        fail ArgumentError, "Missing the required parameter 'payload' when calling MessagingApi.send_sms"
      end
      # resource path
      local_var_path = '/messages/sms'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:body] || @api_client.object_to_http_body(payload) 

      # return_type
      return_type = opts[:return_type] || 'MessageSentResponseSms' 

      # auth_names
      auth_names = opts[:auth_names] || ['auth']

      new_options = opts.merge(
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: MessagingApi#send_sms\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
